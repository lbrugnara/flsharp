(* Copyright (c) Leonardo Brugnara *)
(* Full copyright and license information in LICENSE file *)

(* Start *)
program	-> declaration*
        ;


(* Declarations *)
declaration	-> func_declaration 
			| variable_declaration
			| constant_declaration
			| statement
            ;


(* Function *)
func_declaration -> 'fn' IDENTIFIER '(' func_params? ')' '{' declaration* '}'
                 ;


func_params -> IDENTIFIER ( ',' IDENTIFIER )*
            ;


(* Variable Declaration *)
variable_declaration -> implicit_var_declaration 
					 | typed_var_declaration
                     ;


implicit_var_declaration -> VAR ( IDENTIFIER '=' expression | var_destructuring ) ';'
                         ;


var_destructuring -> '(' ( ',' | IDENTIFIER )+ ')' '=' expression
                  ;


typed_var_declaration -> IDENTIFIER ( '[' ']' )* ( typed_var_definition | var_destructuring ) ';'
                      ;


typed_var_definition -> IDENTIFIER ( '=' expression ( ',' typed_var_definition )* )?
                     ;


(* Constant declaration *)
constant_declaration -> CONST IDENTIFIER IDENTIFIER '=' expression ( ',' IDENTIFIER '=' expression )* ) ';'
                     ;


(* Statements *)
statement	-> expression_statement
			| if_statement
			| while_statement
			| for_statement
			| break_statement
			| continue_statement
			| return_statement
			| block
            ;


parenthesized_expr  -> '(' expression ')' ( statement | ';' )
                    ;


braced_expr -> expression block
            ;


expression_statement -> expression ';'
                     ;


block -> '{' declaration* '}'
      ;


(* Conditional Statements *)
if_statement -> 'if' ( parenthesized_expr | braced_expr ) ( 'else' ( statement | ';' ) )?
             ;


(* Loop statements *)
while_statement -> 'while' ( parenthesized_expr | braced_expr )
                ;


for_statement   -> 'for' '(' for_initializer? ';' expression? ';' for_iterator? ')' statement
			    | 'for' for_initializer? ';' expression? ';' for_iterator? block
                ;


for_initializer -> for_declaration
				| expression ( ',' expression )*
                ;


for_declaration -> ( implicit_var_declaration | typed_var_declaration )
                ;


for_iterator -> expression_list
             ;


break_statement -> 'break' INTEGER? ';'
                ;


continue_statement  -> 'continue' ';'
                    ;


return_statement -> 'return' ( expression ( ',' expression )* )? ';'
                 ;


(* Expressions *)

expression	-> expression_assignment
            ;


expression_assignment	-> ( member_access | destructuring ) ( ( '=' | '+=' | '-=' | '/=' | '*=' )  expression_assignment )?
						| lambda_expression
						| conditional_expression
                        ;


expression_list -> expression ( ',' expression )*
                ;


member_access   -> IDENTIFIER ( '.' IDENTIFIER | arguments )*
                ;


(* Collection destructuring *)
destructuring   -> '(' IDENTIFIER ( '.' IDENTIFIER )* ( ',' destructuring )* ')'
                ;


tuple_initializer   -> '(' expression_list? ')'
                            ;


(* Ternay operator *)
conditional_expression  -> null_coalescing_expression ( '?' expression ':' expression )?
                        ;


(* Null coalescing operator *)
null_coalescing_expression  -> or_expression ( '??' null_coalescing_expression )?
                            ;


(* Lambdas *)
lambda_expression   -> lambda_params '=>' ( block | expression )
                    ;


lambda_params -> '(' func_params ')'
			  | func_params
              ;


or_expression	-> and_expression ( '||' and_expression )*
                ;


and_expression	-> equality_expression ( '&&' equality_expression )*
                ;


equality_expression	-> comparison_expression ( ( '!=' | '==' ) comparison_expression )*
                    ;


comparison_expression	-> addition_expression ( ( '>' | '>=' | '<' | '<=' ) addition_expression )*
                        ;


addition_expression	-> multiplication_expression ( ( '-' | '+' ) multiplication_expression )*
                    ;


multiplication_expression	-> unary_expression ( ( '/' | '*' ) unary_expression )*
                            ;


unary_expression	-> ( '!' | '-' ) unary_expression
					| ( '++' | '--' ) primary_expression
					| primary_expression ( '++' | '--' )?
                    ;


primary_expression  -> primary ( '.' IDENTIFIER | indexer | arguments )*
                    ;


indexer -> '[' expression_list ']'
        ;


arguments -> '(' expression_list? ')'
          ;


primary	-> 'true' 
		| 'false' 
		| 'null' 
		| INTEGER 
		| DOUBLE 
		| DECIMAL 
		| STRING 
		| IDENTIFIER
		| tuple_initializer
		| '(' expression ')'
        ;