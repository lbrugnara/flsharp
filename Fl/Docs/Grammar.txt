# Copyright (c) Leonardo Brugnara
# Full copyright and license information in LICENSE file

# Start

program	-> declaration*

# Declarations

declaration	-> func_declaration 
			| variable_declaration
			| constant_declaration
			| statement

func_declaration -> 'fn' IDENTIFIER '(' func_params? ')' '{' declaration* '}'

func_params -> IDENTIFIER ( ',' IDENTIFIER )*

variable_declaration -> implicit_var_declaration 
					| typed_var_declaration

implicit_var_declaration -> VAR IDENTIFIER '=' expression ';'

typed_var_declaration -> IDENTIFIER ( '[' ']' )* typed_var_definition ';'

typed_var_definition -> IDENTIFIER ( '=' expression ( ',' typed_var_definition )* )?

constant_declaration -> CONST IDENTIFIER? IDENTIFIER '=' expression ';'

# Statements

statement	-> expression_statement
			| if_statement
			| while_statement
			| for_statement
			| break_statement
			| continue_statement
			| return_statement
			| block

parenthesized_expr -> '(' expression ')' ( statement | ';' )

braced_expr -> expression block

expression_statement	-> expression ';'

block	-> '{' declaration* '}'

### Conditional Statements

if_statement -> 'if' ( parenthesized_expr | braced_expr ) ( 'else' ( statement | ';' ) )?

### Loop statements

while_statement -> 'while' ( parenthesized_expr | braced_expr )

for_statement -> 'for' '(' for_initializer? ';' expression? ';' for_iterator? ')' statement
			   | 'for' for_initializer? ';' expression? ';' for_iterator? block

for_initializer -> for_declaration
				| expression ( ',' expression )*

for_declaration -> ( implicit_var_declaration | typed_var_declaration )

for_iterator -> expression_list

break_statement -> 'break' INTEGER? ';'

continue_statement -> 'continue' ';'

return_statement -> 'return' ( expression ( ',' expression )* )? ';'

### Expressions

expression_list -> expression ( ',' expression )*

expression	-> expression_assignment

expression_assignment	-> ( left_hand_side_expr | destructuring ) ( ( '=' | '+=' | '-=' | '/=' | '*=' )  expression_assignment )?
						| lambda_expression
						| tuple_initializer
						| conditional_expression

left_hand_side_expr -> IDENTIFIER ( '.' IDENTIFIER | arguments )*

destructuring -> '(' IDENTIFIER ( '.' IDENTIFIER )* ( ',' destructuring )* ')'

conditional_expression -> null_coalescing_expression ( '?' expression ':' expression )?

null_coalescing_expression -> or_expression ( '??' null_coalescing_expression )?

lambda_expression -> lambda_params '=>' lambda_body

lambda_params -> '(' func_params ')'
			  | func_params

lambda_body -> block
			| expression

tuple_initializer -> '(' expression_list? ')'

or_expression	-> and_expression ( '||' and_expression )*

and_expression	-> equality_expression ( '&&' equality_expression )*

equality_expression	-> comparison_expression ( ( '!=' | '==' ) comparison_expression )*

comparison_expression	-> addition_expression ( ( '>' | '>=' | '<' | '<=' ) addition_expression )*

addition_expression	-> multiplication_expression ( ( '-' | '+' ) multiplication_expression )*

multiplication_expression	-> unary_expression ( ( '/' | '*' ) unary_expression )*

unary_expression	-> ( '!' | '-' ) unary_expression
					| ( '++' | '--' ) primary_expression
					| primary_expression ( '++' | '--' )?

primary_expression -> primary ( '.' IDENTIFIER | indexer | arguments )*

indexer -> '[' expression_list ']'

arguments -> '(' expression_list? ')'

primary	-> 'true' 
		| 'false' 
		| 'null' 
		| INTEGER 
		| DOUBLE 
		| DECIMAL 
		| STRING 
		| IDENTIFIER
		| '(' expression ')'